<div align="center">
<br />
    <img src="./nethermind.png" alt="Ethereum" width="80" >

<br />
  <h2 align="center">Horus</h2>
  <p align="center">
    Formal verification of <a href="https://www.cairo-lang.org/">Cairo</a> programs with language annotations
    <br />
    <a href="https://github.com/NethermindEth/horus-checker/issues">Report bug</a>
    Â·
    <a href="https://github.com/NethermindEth/horus-checker/issues">Request feature</a>
  </p>
</div>

<br>

## Introduction

Horus is a command-line formal verification tool for annotating
[StarkNet](https://starkware.co/starknet/) contracts with assertions and
verifying that they hold using one or more SMT (satisfiability modulo theory)
solvers.

### Our documentation

Our documentation is organized as follows:
* [**Installation**](#installation) - Get the `horus-compile` and
  `horus-check` executables setup for your development environment.
* [Tutorial: Your first verified Cairo program](#tutorial-your-first-verified-cairo-program) - Try this if you're
  new to Horus and want to get a taste of verification in Cairo.  This will
  walk you through an example step-by-step.
* [FAQ](#faq) - What is Cairo? What is Horus? When should I use Horus? Why should
  I use Horus? All these answered and more!
* [How-to guides](#how-to-guides) - If you're already using Horus, and you want
  to know how to do a specific thing, look here! These are like formal
  verification recipes.
* [Usage](#usage) - Exhastive reference information on the CLI options, among
  other things. No explanation or context here. Look here if you just need to
  look something up super quick.
* [Discussion](#discussion) - In which we explain why things are implemented the
  way they are, and discuss details relevant to the development of Horus. This
  is prose to aid contributors and onboard new team members.
* [API Reference](#api-reference) - Autogenerated from the docstrings in both the
  Haskell and Python codebases.


## Installation

Horus is supported on Linux and MacOS (including AArch64 Macs)!

### Prerequisites

- [Python 3.7](https://www.python.org/downloads/release/python-379/)
- [Stack](https://docs.haskellstack.org/en/stable/) (Haskell build tool)
- [Poetry](https://python-poetry.org/) (Python package and dependency manager)
- [Z3](https://github.com/Z3Prover/z3) (version 4.10.2)
- [MathSAT](https://mathsat.fbk.eu/) (version 5.6.8)


<br>

### Installing Python 3.7

Check your python version:
```console
python3 --version
```
<sub>Expected output:</sub>
```
Python 3.7.15
```

If you see `3.7` as in above (any variant of 3.7 should be okay), **you can
skip head to [installing stack](#installing-stack).**

Otherwise, you may have a different version, or you may not have python
installed at all. Follow the instructions below to install the needed version.


1.  Download and install
    [`miniconda`](https://docs.conda.io/en/latest/miniconda.html) on your
    system:

    * [Linux 64-bit](https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh)
    * [macOS Intel x86 64-bit](https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh)
    * [macOS Apple M1 64-bit](https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh)
    * [Windows](https://repo.anaconda.com/miniconda/Miniconda3-latest-Windows-x86_64.exe)

    In each case, run the downloaded script/executable, and follow the instructions.

2.  Create a conda environment with python 3.7:

    ```console
    conda create -n horus-py37 python=3.7
    ```
    In the above, `horus-py37` is just a name we've chosen for this environment.

3.  Activate the created environmment:

    ```console
    conda activate horus-py37
    ```

4.  Verify that you're running 3.7:
    ```console
    python3 --version
    ```
    <sub>Expected output:</sub>
    ```
    Python 3.7.15
    ```

### Installing the Haskell tool stack

###### On Linux:
  ```console
  curl -sSL https://get.haskellstack.org/ | sh
  ```

###### On macOS:
  ```console
  brew install stack
  ```

  > These setup instructions assume that you have [Homebrew](https://brew.sh/) installed on your Mac.

<br>


Check that the install was successful:
```console
stack --version
```

<sub>Expected output (something like this):</sub>
```
Version 2.7.5, Git revision ba147e6f59b2da75b1beb98b1888cce97f7032b1 x86_64 hpack-0.34.4
```

### Install poetry

  ```console
  pip3 install poetry
  ```

### Clone repositories

Clone the `horus-compile` and `horus-checker` repositories to your machine.

```console
git clone git@github.com:NethermindEth/horus-compile.git
git clone git@github.com:NethermindEth/horus-checker.git
```

### Install SMT solvers

Navigate to the `horus-checker/` repository root.

  ```console
  cd horus-checker/
  ```

###### On Linux:
  ```console
  # Inside the `horus-checker/` repository root.
  sh ./scripts/ci/install-z3-linux.sh
  sh ./scripts/ci/install-mathsat-linux.sh
  ```

###### On macOS:
  ```console
  # Inside the `horus-checker/` repository root.
  sh ./scripts/ci/install-z3-macos.sh
  sh ./scripts/ci/install-mathsat-macos.sh
  ```

### Create a python virtual environment

If you're using `conda`, you can skip to [install `horus-compile`](#install-horus-compile).

Otherwise, navigate to the `horus-compile/` repository root and run the following commands:

```console
python -m venv .venv/horus
source .venv/horus/bin/activate
```
<sup>In the above, `horus` is just the name we chose for our virtual environment.</sup>

### Install `horus-compile`

Make sure you're inside the `horus-compile` repository root.

On Linux:
```console
pip install .
```
On macOS:
```console
CFLAGS=-I`brew --prefix gmp`/include LDFLAGS=-L`brew --prefix gmp`/lib pip install .
```

<br>

### Install `horus-checker`

Navigate to the `horus-checker` repository root and run:
```console
stack build
```

You can check that the install was successful with:
```console
stack exec check -- --help
```

If the above command was executed without error, then you are finished with the initial setup and are now ready to work with Horus!

<br>

## Tutorial: Your first verified Cairo program

Let's verify the semantics of a cairo program! First, we'll write a simple
program that implements a stack data structure in Cairo. If you're unfamiliar
with Cairo, or you need a refresher, check out the
[documentation](https://www.cairo-lang.org/docs/)!

Let's define a [`struct`](https://www.cairo-lang.org/docs/reference/syntax.html#structs)
called `Stack` with two members:
* one called `value` which has type [`felt`](https://www.cairo-lang.org/docs/hello_cairo/intro.html#field-element),
* one called `next` of type `Stack*`, which means it's a pointer to an instance
of the struct `Stack` that we're currently defining.

```cairo
struct Stack {
    value: felt,
    next: Stack*,
}
```

Intuitively, we are representing our stack as a linked list. The `value` is the
head of the list, i.e. the top of the stack, and the `next` member is a pointer
to the next node in the list.

Now we've got bare a data structure. Let's define some functions that operate on it.

First, we'll define a function that takes no arguments and returns a pointer to a `Stack`.
```cairo
func empty() -> (stack: Stack*) {
    return (cast(0, Stack*),);
}
```
The use of `cast()` above is a
[typed reference](https://www.cairo-lang.org/docs/how_cairo_works/consts.html?highlight=cast#typed-references).

We'll also also define a function that adds the top two elements on the stack.
It will take one argument, which will be a poointer to a stack, and it will
have one return value, also a pointer to a stack.

If we do things right, we expect that the return value points to a stack in
which the top two elements of the stack represented by the argument have been
summed.

We can use
[member accessor notation](https://www.cairo-lang.org/docs/how_cairo_works/consts.html?highlight=cast#typed-references)
to access the appropriate data from our parameter `stack`.

```cairo
func add(stack: Stack*) -> (stack: Stack*) {
    let x = stack.value;
    let y = stack.next.value;
    return (new Stack(value=x + y, next=stack.next.next),);
}
```

We use the
[`new` operator](https://www.cairo-lang.org/docs/how_cairo_works/object_allocation.html?highlight=new#the-new-operator)
which creates a specified object, in this case a `Stack`, in the
[execution segment](https://www.cairo-lang.org/docs/how_cairo_works/segments.html#the-program-and-execution-segments)
of our program. It then returns a pointer to the newly created object, which
agrees with the stated type of our return value.

Next, we'll define a function called `lit()` for pushing values onto the stack. It is convention to call this operation `LIT` since in implementations of stack machines and stack-based languages,
> *LIT is the primitive word for pushing a "literal" number onto the data stack. -[Wikipedia page for Forth](https://en.wikipedia.org/wiki/Forth_(programming_language))*

Our function will take two arguments, a pointer to a stack, and a literal value
`i`, which has type
[`felt`](https://www.cairo-lang.org/docs/hello_cairo/intro.html#field-element).
It will return, as you might guess, a pointer to a stack to which the literal
`i` has been pushed.

```cairo
func lit(stack: Stack*, i: felt) -> (stack: Stack*) {
    return (new Stack(value=i, next=stack),);
}
```

And finally, we'll define a function `top()` which simply returns the top value
on the stack without modifying the stack.
```cairo
func top(stack: Stack*) -> (res: felt) {
    return (stack.value,);
}
```

We can wrap all these functions up in a namespace to clarify usage.

```cairo
namespace _Stack {
    func empty() -> (stack: Stack*) {
        return (cast(0, Stack*),);
    }

    func add(stack: Stack*) -> (stack: Stack*) {
        let x = stack.value;
        let y = stack.next.value;
        return (new Stack(value=x + y, next=stack.next.next),);
    }

    func lit(stack: Stack*, i: felt) -> (stack: Stack*) {
        return (new Stack(value=i, next=stack),);
    }

    func top(stack: Stack*) -> (res: felt) {
        return (stack.value,);
    }
}
```

Great! Now we'll just add a short `main()` function to test that our stack
functions as we expect. Below is the whole program so far:

```cairo
// Declare that our program will produce output, and import a function to
// perform this IO.
%builtins output
from starkware.cairo.common.serialize import serialize_word

struct Stack {
    value: felt,
    next: Stack*,
}

namespace _Stack {
    func empty() -> (stack: Stack*) {
        return (cast(0, Stack*),);
    }

    func add(stack: Stack*) -> (stack: Stack*) {
        let x = stack.value;
        let y = stack.next.value;
        return (new Stack(value=x + y, next=stack.next.next),);
    }

    func lit(stack: Stack*, i: felt) -> (stack: Stack*) {
        return (new Stack(value=i, next=stack),);
    }

    func top(stack: Stack*) -> (res: felt) {
        return (stack.value,);
    }
}

// Perform some example operations on a stack to sum two integers, and then
// print the result.
func main{output_ptr : felt*}() -> () {
    let (stack) = _Stack.empty();
    let (stack) = _Stack.lit(stack, 5);
    let (stack) = _Stack.lit(stack, 6);
    let (stack) = _Stack.add(stack);
    let (top) = _Stack.top(stack);
    serialize_word(top);
    return ();
}
```

Note that we've added a compiler directive [`%builtins output`](https://www.cairo-lang.org/docs/hello_cairo/intro.html#writing-a-main-function). The Cairo documentation explains this:

> The directive `%builtins output` instructs the Cairo compiler that our program will use the âoutputâ builtin.

For the purposes of this example, this just allows us to print stuff.

We are then allowed to import the `serialize_word()` library function:
```cairo
from starkware.cairo.common.serialize import serialize_word
```
You can think of it like `print()`.

The main function above takes no arguments and returns no values. There is an
implicit argument `output_ptr` that we need in order to perform output. We push
two literals to an empty stack, add them, and then print the result.


Let's try it out! If you've installed everything correctly, you should have the
`cairo-compile` and `cairo-run` executables on your `PATH`.

```console
cairo-compile --version
```
<sub>Expected output:</sub>
```
cairo-compile 0.10.1
```

```console
cairo-run --version
```
<sub>Expected output:</sub>
```
cairo-run 0.10.1
```

Now let's put our program source code in a file and compile it. You can
download it from
[here](https://raw.githubusercontent.com/NethermindEth/horus-checker/example.cairo).

Run:
```console
cairo-compile example.cairo --output compiled.json
```

The compiler outputs a JSON file, which we name `compiled.json`. If everything
went according to plan, you should see this file in your current working
directory.

We can run this compiled program using `cairo-run`:
```console
cairo-run --program compiled.json --layout all --print_output
```

<sub>Expected output:</sub>
```
Program output:
  11

```

Fantastic!


## Usage

#### Using `horus-check`

In the `horus-checker` directory, you should now be able to use the Horus checker after installing the Haskell dependencies using `stack`.

In order to use the Horus checker you would need to have used `horus-compile` to generate a JSON file including the compiled code and other attributes required by the checker.

<br>

Thereafter you can point to the specific JSON file that you would like to run the Horus checker over, you will also need to use the `-s` flag to specify which SMT solvers you would like to use for the testing:

<br>

```
stack exec horus-check -- ./<path-to-file>/example.json -s z3
```

<br>

> You can also call the Horus checker with multiple SMT solvers, below you can see the same example but with all the solver options added after the `-s` flag:

```console
stack exec horus-check -- ./<path-to-file>/example.json -s z3 mathsat cvc5
```

<br>

#### Horus Checker options

Flags for `stack exec horus-check`:

- `-v` (verbose) = If the flag is set all the intermediate steps are printed out.
- `-output-queries` = Stores the (unoptimized) SMT queries for each module in .smt2 files inside DIR.
- `output-optimized-queries` = Stores the (optimized) SMT queries for each module in .smt2 files inside DIR.
- `print-models` = Print models for SAT results.
- `-t` (timeout) = Time limit (ms) for the smt solver.

<br>

#### Annotations

Horus works using an annotation system similar to Cairo itself, however Horus annotations are written in comments. For example:

```
# @post $Result.res == 3
func example() -> (res):
	return (3)
end
```
The following annotations are supported.

<br/>

### `@post`
Specifies conditions that must be true when the function returns.

Example:
```cairo
# @post $Return.res < 100 && $Return.res >= 50
```
No claim is made about whether the function completes or reverts, but that if it completes then the postcondition holds.

<br/>

### `@pre`
Restricts the initial state, value of [logical variables](#declare), or set of possible inputs.

Example:
```cairo
# @pre flag * (flag - 1) == 0
```

<br/>

### `@declare`
Allows the introduction of logical variables.

Example:
```cairo
# @declare $x : felt
```
A **logical variable** is a variable defined and used within a function spec
(i.e.  a set of annotations for a function, i.e. a set of lines starting with
`# @`) for conveniently referring to subexpressions. They play the same role
that ordinary variables do in any programming language, but they can only be
used within `horus` annotations.

In the above example, `$x` is the logical variable being declared.

Logical variable names must begin with a `$`. Note that if a logical variable
is not mentioned in the precondition, then the spec must hold for all possible
values of that variable.

<br/>

### `@storage_update`
Allows claims to be made about the state of a storage variable before and after the function.

> The first new primitive that we see in the code is `@storage_var`. Unlike a
> Cairo program, which is stateless, StarkNet contracts have a state, called
> âthe contractâs storageâ. Transactions invoked on such contracts may modify
> this state, in a way defined by the contract.
>
> The `@storage_var` decorator declares a variable which will be kept as part
> of this storage. In our case, this variable consists of a single felt, called
> balance. To use this variable, we will use the `balance.read()` and
> `balance.write()` functions which are automatically created by the
> `@storage_var` decorator. When a contract is deployed, all its storage cells
> are initialized to zero. In particular, all storage variables are initially
> zero.
>
> *From the Cairo documentation on [writing Starknet contracts](https://www.cairo-lang.org/docs/hello_starknet/intro.html?highlight=storage%20variable)*

Example:
```cairo
# @storage_update x() := x() + 1
```
A storage update must be included for all storage variables modified by a
function otherwise it will not meet the spec.

Only the top-level storage variable reference on the left hand side refers to
the state after the function. As such, if `x` took one input and we specified
the update as such `x(y()) := x(y()) + 1`, both instances of `y()` refer to the
state before the function was called. If you would like to make claims about
the relationship between multiple storage variables after the function is
complete, this can be achieved via the use of logical variables. To do so,
equate your 'before' logical variable to the storage variable in the
precondition. Then, also in the precondition, relate the 'after' and 'before'
logical variables. Finally assign the 'after' logical variable to the storage
variable in a storage update annotation.

<br/>

### `@invariant`
Introduces a constraint attached to a label, typically used for loop invariants.

Example:
```cairo
# @invariant i <= 10
```
The invariant annotation is only required in the case of low level loops
implemented with jump instructions, however it can also be used to make claims
that must hold at any specific point in a function by adding an appropriately
named label and attaching the annotation to it.  Note that this effectively
splits the function in two, and that anything from before the invariant that is
not mentioned within it cannot be used after.

### Spec syntax

The following are allowed within logical formula:
* `a`, `$a` cairo references and logical variables can be used by name
* `$Return.a` the special logical variable `$Return` is defined to contain the values returned from the function
* `a+b`, `a==b`, erc arithmetic operations and comparisons are supported for felts as in cairo
* `a==b or c==d`, `a==b and c==d`, `! a==b`, `a==b -> c==d` propositional logic operators are written as such
* `True`, `False` are defined as keywords
