<div align="center">
<br />
    <img src="./nethermind.png" alt="Ethereum" width="80" >

<br />
  <h2 align="center">Horus</h2>
  <p align="center">
    Formal verification of <a href="https://www.cairo-lang.org/">Cairo</a> programs with language annotations
    <br />
    <a href="https://github.com/NethermindEth/horus-checker/issues">Report bug</a>
    ·
    <a href="https://github.com/NethermindEth/horus-checker/issues">Request feature</a>
  </p>
</div>

<br>

## Introduction

Horus is a command-line formal verification tool for annotating
[StarkNet](https://starkware.co/starknet/) contracts with assertions and
verifying that they hold using one or more SMT (satisfiability modulo theory)
solvers.

### Our documentation

Our documentation is organized as follows:
* [**Installation**](#installation) - Get the `horus-compile` and
  `horus-check` executables setup for your development environment.
* [Tutorial: Your first verified Cairo program](#tutorial-your-first-verified-cairo-program) - Try this if you're
  new to Horus and want to get a taste of verification in Cairo.  This will
  walk you through an example step-by-step.
* [FAQ](#faq) - What is Cairo? What is Horus? When should I use Horus? Why should
  I use Horus? All these answered and more!
* [How-to guides](#how-to-guides) - If you're already using Horus, and you want
  to know how to do a specific thing, look here! These are like formal
  verification recipes.
* [Usage](#usage) - Exhastive reference information on the CLI options, among
  other things. No explanation or context here. Look here if you just need to
  look something up super quick.
* [Discussion](#discussion) - In which we explain why things are implemented the
  way they are, and discuss details relevant to the development of Horus. This
  is prose to aid contributors and onboard new team members.
* [API Reference](#api-reference) - Autogenerated from the docstrings in both the
  Haskell and Python codebases.


## Installation

Horus is supported on Linux and MacOS (including AArch64 Macs)!

### Prerequisites

- [Python 3.7](https://www.python.org/downloads/release/python-379/)
- [Stack](https://docs.haskellstack.org/en/stable/) (Haskell build tool)
- [Poetry](https://python-poetry.org/) (Python package and dependency manager)
- [Z3](https://github.com/Z3Prover/z3) (version 4.10.2)
- [MathSAT](https://mathsat.fbk.eu/) (version 5.6.8)


<br>

### Installing Python 3.7

Check your python version:
```console
python3 --version
```
<sub>Expected output:</sub>
```
Python 3.7.15
```

If you see `3.7` as in above (any variant of 3.7 should be okay), **you can
skip head to [installing stack](#installing-stack).**

Otherwise, you may have a different version, or you may not have python
installed at all. Follow the instructions below to install the needed version.


1.  Download and install
  [`miniconda`](https://docs.conda.io/en/latest/miniconda.html) on your
  system:

  * [Linux 64-bit](https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh)
  * [macOS Intel x86 64-bit](https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh)
  * [macOS Apple M1 64-bit](https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh)
  * [Windows](https://repo.anaconda.com/miniconda/Miniconda3-latest-Windows-x86_64.exe)

  In each case, run the downloaded script/executable, and follow the instructions.

2.  Create a conda environment with python 3.7:

  ```console
  conda create -n horus-py37 python=3.7
  ```
  In the above, `horus-py37` is just a name we've chosen for this environment.

3.  Activate the created environmment:

  ```console
  conda activate horus-py37
  ```

4.  Verify that you're running 3.7:
  ```console
  python3 --version
  ```
  <sub>Expected output:</sub>
  ```
  Python 3.7.15
  ```

### Installing the Haskell tool stack

###### On Linux:
```console
curl -sSL https://get.haskellstack.org/ | sh
```

###### On macOS:
```console
brew install stack
```

> These setup instructions assume that you have [Homebrew](https://brew.sh/) installed on your Mac.

<br>


Check that the install was successful:
```console
stack --version
```

<sub>Expected output (something like this):</sub>
```
Version 2.7.5, Git revision ba147e6f59b2da75b1beb98b1888cce97f7032b1 x86_64 hpack-0.34.4
```

### Install poetry

```console
pip3 install poetry
```

### Clone repositories

Clone the `horus-compile` and `horus-checker` repositories to your machine.

```console
git clone git@github.com:NethermindEth/horus-compile.git
git clone git@github.com:NethermindEth/horus-checker.git
```

### Install SMT solvers

Navigate to the `horus-checker/` repository root.

```console
cd horus-checker/
```

###### On Linux:
```console
# Inside the `horus-checker/` repository root.
sh ./scripts/ci/install-z3-linux.sh
sh ./scripts/ci/install-mathsat-linux.sh
```

###### On macOS:
```console
# Inside the `horus-checker/` repository root.
sh ./scripts/ci/install-z3-macos.sh
sh ./scripts/ci/install-mathsat-macos.sh
```

### Create a python virtual environment

If you're using `conda`, you can skip to [install `horus-compile`](#install-horus-compile).

Otherwise, navigate to the `horus-compile/` repository root and run the following commands:

```console
python -m venv .venv/horus
source .venv/horus/bin/activate
```
<sup>In the above, `horus` is just the name we chose for our virtual environment.</sup>

### Install `horus-compile`

Make sure you're inside the `horus-compile` repository root.

On Linux:
```console
pip install .
```
On macOS:
```console
CFLAGS=-I`brew --prefix gmp`/include LDFLAGS=-L`brew --prefix gmp`/lib pip install .
```

<br>

### Install `horus-checker`

Navigate to the `horus-checker` repository root and run:
```console
stack build
```

You can check that the install was successful with:
```console
stack exec check -- --help
```

If the above command was executed without error, then you are finished with the initial setup and are now ready to work with Horus!

<br>

## Tutorial: Your first verified Cairo program

Let's verify the semantics of a cairo program! First, we'll write a simple
program that implements a stack data structure in Cairo. If you're unfamiliar
with Cairo, or you need a refresher, check out the
[documentation](https://www.cairo-lang.org/docs/)!

#### Define a struct called `Stack`

Let's define a [`struct`](https://www.cairo-lang.org/docs/reference/syntax.html#structs)
called `Stack` with two members:
* one called `value` which has type [`felt`](https://www.cairo-lang.org/docs/hello_cairo/intro.html#field-element),
* one called `next` of type `Stack*`, which means it's a pointer to an instance
of the struct `Stack` that we're currently defining.

```cairo
struct Stack {
  value: felt,
  next: Stack*,
}
```

Intuitively, we are representing our stack as a linked list. The `value` is the
head of the list, i.e. the top of the stack, and the `next` member is a pointer
to the next node in the list.

Now we've got a bare data structure. Let's define some functions that operate on it.

#### Define a function that constructs an empty `Stack`

First, we'll define a function called `empty()` that takes no arguments and
returns a pointer to a new, empty `Stack`.
```cairo
struct Stack {
  value: felt,
  next: Stack*,
}

func empty() -> (stack: Stack*) {
  return (cast(0, Stack*),);
}
```
The use of `cast()` above is a
[typed reference](https://www.cairo-lang.org/docs/how_cairo_works/consts.html?highlight=cast#typed-references).

#### Define a function that adds the top two elements on the stack

We'll also define a function called `add()`. It will take one argument, which
will be a pointer to a stack, and it will have one return value, also a pointer
to a stack.

We can use
[member accessor notation](https://www.cairo-lang.org/docs/how_cairo_works/consts.html?highlight=cast#typed-references)
to access the appropriate data from our parameter `stack`.

```cairo
struct Stack {
  value: felt,
  next: Stack*,
}

func empty() -> (stack: Stack*) {
  return (cast(0, Stack*),);
}

func add(stack: Stack*) -> (stack: Stack*) {
  let x = stack.value;
  let y = stack.next.value;
  return (new Stack(value=x + y, next=stack.next.next),);
}
```

We use the
[`new` operator](https://www.cairo-lang.org/docs/how_cairo_works/object_allocation.html?highlight=new#the-new-operator)
which creates a specified object, in this case a `Stack`, in the
[execution segment](https://www.cairo-lang.org/docs/how_cairo_works/segments.html#the-program-and-execution-segments)
of our program. It then returns a pointer to the newly created object. In this
case, it returns a pointer to a `Stack`, and that makes sense, since our return
value is `stack: Stack*`!

#### Define a function that pushes values onto the stack

Next, we'll define a function called `lit()` for pushing values onto the stack.

By convention, `lit` stands for "literal", since we're pushing "literal"
values. This is a naming tradition that originates from implementations of
stack machines and stack-based languages:
> *LIT is the primitive word for pushing a "literal" number onto the data stack. -[Wikipedia page for Forth](https://en.wikipedia.org/wiki/Forth_(programming_language))*

Our function will take two arguments, a pointer to a stack, and a literal value
`i`, which has type
[`felt`](https://www.cairo-lang.org/docs/hello_cairo/intro.html#field-element).
It will return a pointer to a stack to which the literal `i` has been pushed,
and is now the top element.

```cairo
struct Stack {
  value: felt,
  next: Stack*,
}

func empty() -> (stack: Stack*) {
  return (cast(0, Stack*),);
}

func add(stack: Stack*) -> (stack: Stack*) {
  let x = stack.value;
  let y = stack.next.value;
  return (new Stack(value=x + y, next=stack.next.next),);
}

func lit(stack: Stack*, i: felt) -> (stack: Stack*) {
  return (new Stack(value=i, next=stack),);
}
```

#### Define a function to peek the top value of the stack

And finally, we'll define a function `top()` which simply returns the top value
on the stack without modifying the stack.
```cairo
struct Stack {
  value: felt,
  next: Stack*,
}

func empty() -> (stack: Stack*) {
  return (cast(0, Stack*),);
}

func add(stack: Stack*) -> (stack: Stack*) {
  let x = stack.value;
  let y = stack.next.value;
  return (new Stack(value=x + y, next=stack.next.next),);
}

func lit(stack: Stack*, i: felt) -> (stack: Stack*) {
  return (new Stack(value=i, next=stack),);
}

func top(stack: Stack*) -> (res: felt) {
  return (stack.value,);
}
```

#### Add a namespace for our `Stack`-related functions

We can wrap all these functions up in a namespace called `_Stack` to clarify
usage:

```cairo
struct Stack {
  value: felt,
  next: Stack*,
}

namespace _Stack {
  func empty() -> (stack: Stack*) {
      return (cast(0, Stack*),);
  }

  func add(stack: Stack*) -> (stack: Stack*) {
      let x = stack.value;
      let y = stack.next.value;
      return (new Stack(value=x + y, next=stack.next.next),);
  }

  func lit(stack: Stack*, i: felt) -> (stack: Stack*) {
      return (new Stack(value=i, next=stack),);
  }

  func top(stack: Stack*) -> (res: felt) {
      return (stack.value,);
  }
}
```

This means when we call them we must write, for example, `_Stack.add` instead
of just `add`, which makes it slightly clearer what sort of objects we're
operating on, and where to find the implementation of that operation.

#### Add the necessary imports and a `main()` function

Great! Now we'll just add a short `main()` function to test that our stack
functions as we expect.

```cairo
// Declare that our program will produce output, and import a function to
// perform this IO.
%builtins output
from starkware.cairo.common.serialize import serialize_word

struct Stack {
  value: felt,
  next: Stack*,
}

namespace _Stack {
  func empty() -> (stack: Stack*) {
      return (cast(0, Stack*),);
  }

  func add(stack: Stack*) -> (stack: Stack*) {
      let x = stack.value;
      let y = stack.next.value;
      return (new Stack(value=x + y, next=stack.next.next),);
  }

  func lit(stack: Stack*, i: felt) -> (stack: Stack*) {
      return (new Stack(value=i, next=stack),);
  }

  func top(stack: Stack*) -> (res: felt) {
      return (stack.value,);
  }
}

// Perform some example operations on a stack to sum two integers, and then
// print the result.
func main{output_ptr : felt*}() -> () {
  let (stack) = _Stack.empty();
  let (stack) = _Stack.lit(stack, 5);
  let (stack) = _Stack.lit(stack, 6);
  let (stack) = _Stack.add(stack);
  let (top) = _Stack.top(stack);
  serialize_word(top);
  return ();
}
```

Note that we've added a compiler directive [`%builtins output`](https://www.cairo-lang.org/docs/hello_cairo/intro.html#writing-a-main-function). The Cairo documentation explains this:

> The directive `%builtins output` instructs the Cairo compiler that our program will use the “output” builtin.

For the purposes of this example, this just allows us to print stuff.

We are then allowed to import the `serialize_word()` library function:
```cairo
from starkware.cairo.common.serialize import serialize_word
```
You can think of it like `print()`.

The main function above takes no arguments and returns no values. There is an
implicit argument `output_ptr` that we need in order to perform output. Our
example `main()` function pushes two literals to an empty stack, adds them, and
then prints the result.

#### Compile and run our example program

Let's try it out! If you've installed everything correctly, you should have the
`cairo-compile` and `cairo-run` executables on your `PATH`.

###### Check that `cairo-compile` is installed
```console
cairo-compile --version
```
<sub>Expected output:</sub>
```
cairo-compile 0.10.1
```

<br>

###### Check that `cairo-run` is installed
```console
cairo-run --version
```
<sub>Expected output:</sub>
```
cairo-run 0.10.1
```

Now let's put the source code of the program we just wrote in a file and compile it. You can
download the source code from
[here](https://raw.githubusercontent.com/NethermindEth/horus-checker/example.cairo).

Make sure your file has the name `example.cairo`, and then run the following command:
```console
cairo-compile example.cairo --output compiled.json
```

The compiler outputs a JSON file, which we name `compiled.json`. If everything
goes according to plan, you should see this file in your current working
directory.

We can run this compiled program using `cairo-run`:
```console
cairo-run --program compiled.json --layout all --print_output
```

<sub>Expected output:</sub>
```
Program output:
11

```

And we see that it correctly added the two literal values we pushed, `5` and
`6`. Fantastic!


#### Formally verify our example program

Now, let's add some annotations that describe how we expect our `_Stack`
functions to behave, and then we'll prove that the implementations we wrote
satisfy the specification of behavior given by the annotations.


Here's our program with the annotations:
```cairo
%builtins output
from starkware.cairo.common.serialize import serialize_word

struct Stack {
  value: felt,
  next: Stack*,
}

namespace _Stack {
  func empty() -> (stack: Stack*) {
      return (cast(0, Stack*),);
  }

  // @post $Return.stack.value == stack.value + stack.next.value
  // @post $Return.stack.next == stack.next.next
  func add(stack: Stack*) -> (stack: Stack*) {
      let x = stack.value;
      let y = stack.next.value;
      return (new Stack(value=x + y, next=stack.next.next),);
  }

  // @post $Return.stack.value == i
  // @post $Return.stack.next == stack
  func lit(stack: Stack*, i: felt) -> (stack: Stack*) {
      return (new Stack(value=i, next=stack),);
  }

  // @post $Return.res == stack.value
  func top(stack: Stack*) -> (res: felt) {
      return (stack.value,);
  }
}

// Perform some example operations on a stack.
func main{output_ptr : felt*}() -> () {
  let (stack) = _Stack.empty();
  let (stack) = _Stack.lit(stack, 5);
  let (stack) = _Stack.lit(stack, 6);
  let (stack) = _Stack.add(stack);
  let (top) = _Stack.top(stack);
  serialize_word(top);
  return ();
}
```
The annotations are the comments directly above each of the functions `add()`,
`lit()`, and `top()`. They begin with `// @`. The `@post` keyword indicates
that an annotation is specifying a condition that must hold **at the end of the
function call**, when the function returns. It is called `@post` because it is
a "postcondition".

Briefly, we are asserting that:
* The `add()` function returns a pointer to a stack with the sum of the first two elements on top, and the remainder of the original stack (the third element and so on) after that.
* The `lit` function puts `i` on the top of the stack, and preserves the old stack underneath it.
* The `top` function actually returns the top of the stack we pass as an argument.

Let's compile this annotated program with Horus and then check these properties:
```console
horus-compile annotated.cairo --output compiled.json
```

This should create a file called `compiled.json`. Now let's verify the compiled binary:
```console
horus-check -s z3 compiled.json
```

<sub>Expected output:</sub>
```
_Stack.add
Unsat

_Stack.empty
Unsat

_Stack.lit
Unsat

_Stack.top
Unsat

main
Unsat

cairo.lang.compiler.lib.registers.get_ap
Unsat

empty: (and (= (memory (+ ap (- 2))) (memory (+ fp (- 2)))) (= (memory (+ ap (- 1))) (memory (+ fp (- 1)))))
Unsat
```

The judgement `Unsat` means verified! The three functions `_Stack.add`,
`_Stack.lit`, and `_Stack.top` that we annotated all say `Unsat`, which means
our implementations are correct with respect to the specifications we wrote in
our annotations. Congrats! You've just formally verified your first Cairo
program!


## FAQ

### What is Horus?

Horus is a command-line tool for the [Cairo ecosystem](https://www.cairo-lang.org/).
It helps you [formally verify](https://en.wikipedia.org/wiki/Formal_verification)
Cairo programs and [StarkNet smart contracts](https://starkware.co/starknet/).

The way it works is like this:

1. You write a Cairo program.
2. You add annotations that describe how the program should operate.
3. You run Horus on your program, and Horus tells you if the program obeys the annotations.

> “Program testing can be used to show the presence of bugs, but never to show their absence!”
> ― Edsger W. Dijkstra 

Horus can be used to show the **absence** of bugs.

<br>

Horus consists of two command-line tools, called `horus-compile` and
`horus-check`. The first, `horus-compile`, is a modified version of the Cairo
compiler that you can use to compile a program with [Horus annotations](#annotations).
You can then run `horus-check` on the compiled program to formally verify the
program's behavior.

<br>

### What is Cairo/StarkNet?

[**Cairo**](https://www.cairo-lang.org/) is a [Turing-complete](https://en.wikipedia.org/wiki/Turing_completeness) language for writing [dApps](https://ethereum.org/en/dapps/#what-are-dapps) using [STARKs](https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/zk-starks/). STARK stands for Scalable Transparent Argument of Knowledge.

Basically, it's a programming language that runs on [Layer 2 Ethereum](https://ethereum.org/en/layer-2/) that lets you write programs where one party can prove to another that a certain computation was executed correctly. The syntax is a bit like [Rust](https://www.rust-lang.org/).

[**StarkNet**](https://starkware.co/starknet/) is a Layer 2 network over Ethereum. Specifically, it is a [ZK-Rollup (zero-knowledge rollup)](https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/zk-rollups/), which is basically a way of scaling up the number of transactions that a blockchain can process by bundling (rolling-up) many transactions into one.

You can write StarkNet smart contracts in the Cairo language.

<br>

### When should I use Horus?

Use Horus when you need to be absolutely sure that a Cairo program or StarkNet
contract executes correctly according to some specification. Horus is good for
when you know what your program should do, but you aren't sure that the
implementation actually does that thing, in all cases, no matter what. Horus
will not help you if you don't know exactly what your program should do.

Horus, and formal verification in general, proves that the implementation of a
program **matches the expected behavior**, as expressed in some formal
specification.

You get the most mileage out of this when the expected behavior is simple, but
the implementation is very complex.

<br>

### Why should I use Horus?

Because you love formal verification and care about writing provably correct programs!

> [Really stupid “smart contract” bug let hackers steal $31 million in digital coin](https://arstechnica.com/information-technology/2021/12/hackers-drain-31-million-from-cryptocurrency-service-monox-finance/)

Alternatively, because you don't want your firm to be in the news.

<br>

### What does Horus do?

It uses a modified version of the Cairo compiler to translate your
[function specification annotations](#annotations) into
[SMT solver](https://en.wikipedia.org/wiki/Satisfiability_modulo_theories)
queries. These are mathematical assertions that the desired properties of the
function in question are true for all inputs. Then these queries are run, and
the SMT solver magically tells us whether or not it was able to prove that the
program is sound!


## Usage

Horus consists of two command-line tools, `horus-compile` and `horus-check`.

<br>

### `horus-compile`
```console
horus-compile [options] <file>
```

The `[options]` are described in the [`horus-compile`](#horus-compile) section
below.

The `<file>` argument is a Horus-annotated Cairo program, usually with a
filename of the form `<program>.cairo`.

The `horus-compile` tool emits a compiled Cairo program in the form of JSON.
The JSON output of `horus-compile` is printed to `stdout` by default.

<br>

```console
horus-check --solver <solver_name> <compiled_file>
```

The `<solver_name>` argument above is either `z3`, `cvc5`, or `mathsat`.

The `<compiled_file>` is the output of a `horus-compile` call. This should be a
JSON file. You can save the JSON emitted by `horus-compile` to a file using the
`--output FILE` flag.

<br>

#### Using `horus-check`

In the `horus-checker` directory, you should now be able to use the Horus checker after installing the Haskell dependencies using `stack`.

In order to use the Horus checker you would need to have used `horus-compile` to generate a JSON file including the compiled code and other attributes required by the checker.

<br>

Thereafter you can point to the specific JSON file that you would like to run the Horus checker over, you will also need to use the `-s` flag to specify which SMT solvers you would like to use for the testing:

<br>

```console
stack exec horus-check -- ./<path-to-file>/example.json -s z3
```

<br>

> You can also call the Horus checker with multiple SMT solvers, below you can see the same example but with all the solver options added after the `-s` flag:

```console
stack exec horus-check -- ./<path-to-file>/example.json -s z3 mathsat cvc5
```

<br>

#### Horus Checker options

Flags for `stack exec horus-check`:

- `-v` (verbose) = If the flag is set all the intermediate steps are printed out.
- `-output-queries` = Stores the (unoptimized) SMT queries for each module in .smt2 files inside DIR.
- `output-optimized-queries` = Stores the (optimized) SMT queries for each module in .smt2 files inside DIR.
- `print-models` = Print models for SAT results.
- `-t` (timeout) = Time limit (ms) for the smt solver.

<br>

#### Annotations

Horus works using an annotation system similar to Cairo itself, however Horus annotations are written in comments. For example:

```
// @post $Result.res == 3
func example() -> (res):
	return (3)
end
```
The following annotations are supported.

<br/>

### `@post`
Specifies conditions that must be true when the function returns.

Example:
```cairo
// @post $Return.res < 100 && $Return.res >= 50
```
No claim is made about whether the function completes or reverts, but that if it completes then the postcondition holds.

<br/>

### `@pre`
Restricts the initial state, value of [logical variables](#declare), or set of possible inputs.

Example:
```cairo
// @pre flag * (flag - 1) == 0
```

<br/>

### `@declare`
Allows the introduction of logical variables.

Example:
```cairo
// @declare $x : felt
```
A **logical variable** is a variable defined and used within a function spec
(i.e.  a set of annotations for a function, i.e. a set of lines starting with
`// @`) for conveniently referring to subexpressions. They play the same role
that ordinary variables do in any programming language, but they can only be
used within `horus` annotations.

In the above example, `$x` is the logical variable being declared.

Logical variable names must begin with a `$`. Note that if a logical variable
is not mentioned in the precondition, then the spec must hold for all possible
values of that variable.

<br/>

### `@storage_update`
Allows claims to be made about the state of a storage variable before and after the function.

> The first new primitive that we see in the code is `@storage_var`. Unlike a
> Cairo program, which is stateless, StarkNet contracts have a state, called
> “the contract’s storage”. Transactions invoked on such contracts may modify
> this state, in a way defined by the contract.
>
> The `@storage_var` decorator declares a variable which will be kept as part
> of this storage. In our case, this variable consists of a single felt, called
> balance. To use this variable, we will use the `balance.read()` and
> `balance.write()` functions which are automatically created by the
> `@storage_var` decorator. When a contract is deployed, all its storage cells
> are initialized to zero. In particular, all storage variables are initially
> zero.
>
> *From the Cairo documentation on [writing Starknet contracts](https://www.cairo-lang.org/docs/hello_starknet/intro.html?highlight=storage%20variable)*

Example:
```cairo
// @storage_update x() := x() + 1
```
A storage update must be included for all storage variables modified by a
function otherwise it will not meet the spec.

Only the top-level storage variable reference on the left hand side refers to
the state after the function. As such, if `x` took one input and we specified
the update as such `x(y()) := x(y()) + 1`, both instances of `y()` refer to the
state before the function was called. If you would like to make claims about
the relationship between multiple storage variables after the function is
complete, this can be achieved via the use of logical variables. To do so,
equate your 'before' logical variable to the storage variable in the
precondition. Then, also in the precondition, relate the 'after' and 'before'
logical variables. Finally assign the 'after' logical variable to the storage
variable in a storage update annotation.

<br/>

### `@invariant`
Introduces a constraint attached to a label, typically used for loop invariants.

Example:
```cairo
// @invariant i <= 10
```
The invariant annotation is only required in the case of low level loops
implemented with jump instructions, however it can also be used to make claims
that must hold at any specific point in a function by adding an appropriately
named label and attaching the annotation to it.  Note that this effectively
splits the function in two, and that anything from before the invariant that is
not mentioned within it cannot be used after.

### Spec syntax

The following are allowed within logical formula:
* `a`, `$a` cairo references and logical variables can be used by name
* `$Return.a` the special logical variable `$Return` is defined to contain the values returned from the function
* `a+b`, `a==b`, erc arithmetic operations and comparisons are supported for felts as in cairo
* `a==b or c==d`, `a==b and c==d`, `! a==b`, `a==b -> c==d` propositional logic operators are written as such
* `True`, `False` are defined as keywords
